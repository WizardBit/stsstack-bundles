#!/bin/bash
#
# PLEASE AVOID PUTTING BUNDLE-SPECIFIC CODE IN HERE. INSTEAD USE THE INDIVIDUAL
# BUNDLE GENERATORS.
#
declare -A overlays_deduped=()
declare -a overlay_opts=()

# Catch any changes/additions to master opts
update_master_opts ${MOD_PASSTHROUGH_OPTS[@]}

vip_start=${MASTER_OPTS[VIP_ADDR_START]}
vip_start_prefix=${vip_start%\.*}
vip_start_suffix=${vip_start##*\.}

if [ -z "$MOD_BASE_TEMPLATE" ]; then
    echo "ERROR: no template provided with --template"
    exit 1
elif [ -z "$MOD_DIR" ]; then
    echo "ERROR: no module name provided"
    exit 1
elif has_opt --create-model && [ -z "${MASTER_OPTS[BUNDLE_NAME]}" ]; then
    echo "ERROR: no --name provided so cannot create Juju model"
    exit 1
fi

ensure_model
[ -n "${MASTER_OPTS[MODEL_CONFIG]}" ] && juju model-config ${MASTER_OPTS[MODEL_CONFIG]}

bundles_dir=`get_bundle_state_dir`

if has_opt --list; then
    state_root=`get_bundle_state_root`
    if [ -d "$state_root" ]; then
        echo -e "Existing bundles:\n./b (default)"
        find $state_root/* -maxdepth 0 -type d| egrep -v "/o$|resources"
        echo ""
    else
        echo "There are currently no bundles."
    fi
    exit
fi
mkdir -p $bundles_dir

finish ()
{
    local target

    if has_opt --replay; then
        target=${bundles_dir}/command
        echo -e "INFO: replaying last known command (from $target)\n"
        [ -e "$target" ] || { echo "ERROR: $target does not exist"; exit 1; }
    fi
    echo "Command to deploy:"
    cat ${bundles_dir}/command
    if has_opt --run; then
        . ${bundles_dir}/command
    fi
    has_opt --replay && exit 0 || true
}

# Replay ignores any input args and just prints the previously generated
# command.
has_opt --replay && finish

# Each custom bundle generator can specify a set of parameters to apply to
# bundle templates as variables. They are converted into a sed statement that
# is passed in to here inside a file and run against the template(s). There is
# therefore no need to add parameters to this function and they should only
# be defined in the custom generators.
render () {
    local charm_current
    local charm_new

    # generic parameters only
    sed -i "s,__SERIES__,$series,g" $1

    # service-specific replacements
    if [ -n "$INTERNAL_BUNDLE_CONFIG_RENDERER" ]; then
        eval `cat $INTERNAL_BUNDLE_CONFIG_RENDERER` "$1"
    fi

    if `grep -q __VIP__ $1`; then
        vip=$vip_start_prefix.$((vip_start_suffix++))
        sed -i -r "s/__VIP__/$vip/g" $1
    fi

    # Process charm revisions from bundle first.
    for key in ${!MASTER_OPTS[@]}; do
        prefix="CHARM_REVISIONS\."
        if ! `echo $key| egrep -q "^$prefix"`; then
            continue
        fi
        charm_current=${key##$prefix}
        charm_new=${MASTER_OPTS[$key]}
        sed -i -r "s,charm:.*${charm_current}$,charm: $charm_new," $1
    done

    if has_opt --use-stable-charms; then
        sed -i -r 's,~openstack-charmers-next/,,g' $1
    fi
}

render_resources_path () {
    local file="$1"
    local name=`basename $file`
    local path=resources/${name%%.*}/

    sed -i -r "s,__RESOURCES_PATH__,$path,g" $file
}

if has_opt --use-stable-charms; then
    msg="using stable charms"
else
    msg="using dev/next charms"
fi

channel_param=
if [ -n "${MASTER_OPTS[CHARM_CHANNEL]}" ]; then
    channel_param="--channel=${MASTER_OPTS[CHARM_CHANNEL]}"
fi

# Make copy of base template, render, and store in named dir.
dtmp=`mktemp -d`
template_path=$dtmp/`basename $MOD_BASE_TEMPLATE`
bundle=${template_path%%.template}
cp $MOD_DIR/$MOD_BASE_TEMPLATE $bundle
render $bundle
mv $bundle $bundles_dir
[ -r "$INTERNAL_BUNDLE_CONFIG" ] && \
    cp $INTERNAL_BUNDLE_CONFIG $bundles_dir/config
rmdir $dtmp

# Copy base bundle resources to bundles dir (if exists)
resource_path=$MOD_DIR/resources/
if [ -d "$resource_path" ]; then
    mkdir -p $bundles_dir/resources
    name=`basename $bundle`
    if [ -d "$resource_path/${name%%.yaml}" ]; then
        cp -r $resource_path/${name%%.yaml} $bundles_dir/resources
        # add absolute path for resources
        render_resources_path $bundles_dir/$name
    fi
fi
# De-duplicate overlay list and create bundle structure.
if ((${#MOD_OVERLAYS[@]})); then
    mkdir -p $bundles_dir/o
    declare -a msgs=()
    for overlay in ${MOD_OVERLAYS[@]}; do
        [ "${overlays_deduped[$overlay]:-null}" = "null" ] || continue
        cp $MOD_DIR/overlays/$overlay $bundles_dir/o
        ((${#overlay_opts[@]}==0)) && overlay_opts+=("")  # left padding
        overlay_opts+=( --overlay $bundles_dir/o/$overlay )
        render $bundles_dir/o/$overlay
        overlays_deduped[$overlay]=true
        msgs+=( " + $overlay\n" )
        # Copy overla resources to bundles dir (if exists)
        resource_path=$MOD_DIR/resources/${overlay%%.*}
        if [ -d "$resource_path" ]; then
            mkdir -p $bundles_dir/resources
            cp -r $resource_path $bundles_dir/resources
            # add absolute path for resources
            render_resources_path $bundles_dir/o/$overlay
        fi
    done
    ((${#overlay_opts[@]})) && overlay_opts+=("")  # right padding

    echo "Created ${MASTER_OPTS[TARGET_RELEASE_NAME]} bundle and overlays ($msg):"
    echo -e " ${msgs[@]}"
else
    echo -e "Created ${MASTER_OPTS[TARGET_RELEASE_NAME]} bundle ($msg)\n"
fi

base_bundle=$bundles_dir/`basename $bundle`
echo -e "juju deploy${JUJU_DEPLOY_OPTS} ${base_bundle}${overlay_opts[@]:- }${channel_param}\n " > ${bundles_dir}/command
finish
