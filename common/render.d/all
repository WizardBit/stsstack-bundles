#!/bin/bash

# Renderers defined here must be applied to any/all templates.

__generate_app_mysql_inndodb_router ()
{
    local app="$1"

    mkdir -p $RENDER_PARTS_DIR/mysql/{applications,relations}

cat << EOF > $RENDER_PARTS_DIR/mysql/applications/$app-mysql-innodb-cluster-router.part
  $app-mysql-router:
    charm: cs:~openstack-charmers-next/mysql-router
EOF
cat << EOF > $RENDER_PARTS_DIR/mysql/relations/$app-mysql-innodb-cluster-router.part
  - [ mysql:db-router, $app-mysql-router:db-router ]
EOF
}

__create_mysql_interface_parts ()
{
    local template=$1
    local templates_path=$2
    local template_short=`basename $1`
    local template_key=__APPLICATION_MYSQL_INNODB_ROUTER__

    readarray -t lines<<<"`grep "$template_key" $template`"
    ((${#lines[@]})) && [ -n "${lines[0]}" ] || return 0
    for line in "${lines[@]}"; do
        app=`echo $line| sed -r "s/.*\s+([[:alnum:]\-]+):shared-db.*/\1/g"`
        [ -n "$app" ] || continue
        sed -i -r "s/($app:shared-db\s*,\s*)$template_key/\1$app-mysql-router:shared-db/g" $template
        __generate_app_mysql_inndodb_router $app
    done
}

__create_yaml_dict_entry ()
{
    local section=$1
    shift

    cat <<- EOF
	$section:
	$@
	EOF
}

aggregate_mysql_interface_parts()
{
    # this is called once after all the individial mysql application interface
    # parts have been created.
    local rendered_path=$1
    local dir

    [ -d "$RENDER_PARTS_DIR/mysql" ] || return 0

    ((`find $RENDER_PARTS_DIR/mysql -type f| wc -l`)) || return 0

    # this function is only expected to be called once so ensure clean file.
    echo -e "# overlay auto-generated by stsstack-bundles\n" > $rendered_path/mysql-innodb-cluster-router.yaml
    for key in applications relations; do
        dir=$RENDER_PARTS_DIR/mysql/$key
        [ -d "$dir" ] || return 0
        __create_yaml_dict_entry $key "`cat $dir/*`" >> $rendered_path/mysql-innodb-cluster-router.yaml
    done
}

# Each custom bundle generator can specify a set of parameters to apply to
# bundle templates as variables. They are converted into a sed statement that
# is passed in to here inside a file and run against the template(s). There is
# therefore no need to add parameters to this function and they should only
# be defined in the custom generators.
render () {
    local charm_current
    local charm_new
    local num_vips

    # generic parameters only
    sed -i "s,__SERIES__,$series,g" $1

    # service-specific replacements
    if [ -n "$INTERNAL_BUNDLE_CONFIG_RENDERER" ]; then
        eval `cat $INTERNAL_BUNDLE_CONFIG_RENDERER` "$1"
    fi

    num_vips=`grep __VIP__ $1| wc -l`
    if ((num_vips)); then
        for ((i=0;i<num_vips;i++)); do
            vip=$VIP_START_PREFIX.$((VIP_START_SUFFIX++))
            sed -i "0,/__VIP__/s//$vip/" $1
        done
    fi

    # Process charm revisions from bundle first.
    for key in ${!MASTER_OPTS[@]}; do
        prefix="CHARM_REVISIONS\."
        # skip any key that isnt a charm revision
        [[ ${key##$prefix} != $key ]] || continue
        charm_current=${key##$prefix}
        charm_new=${MASTER_OPTS[$key]}
        # skip if the charm we are replacing isnt in the template
        grep -q $charm_current $1 || continue
        sed -i -r "s,charm:.*${charm_current}\$,charm: $charm_new," $1
    done

    if has_opt --use-stable-charms; then
        sed -i -r 's,~openstack-charmers-next/,,g' $1
    fi

    # render mysql interface if exists
    # note: no changes applied until aggregate_mysql_interface_parts()
    #       called so be sure to do so once all rendering complete.
    __create_mysql_interface_parts $1 $MOD_DIR/overlays
}

